/*
 * Copyright (c) 1991, 1992 Paul Kranenburg <pk@cs.few.eur.nl>
 * Copyright (c) 1993 Branko Lankester <branko@hacktic.nl>
 * Copyright (c) 1993, 1994, 1995, 1996 Rick Sladkey <jrs@world.std.com>
 * Copyright (c) 1996-1999 Wichert Akkerman <wichert@cistron.nl>
 * Copyright (c) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation
 *                     Linux for s390 port by D.J. Barrow
 *                    <barrow_dj@mail.yahoo.com,djbarrow@de.ibm.com>
 * Copyright (c) 1999-2019 The strace developers.
 * All rights reserved.
 *
 * SPDX-License-Identifier: LGPL-2.1-or-later
 */

#include "defs.h"
#include "get_personality.h"
#include "mmap_notify.h"
#include "native_defs.h"
#include "ptrace.h"
#include "ptrace_syscall_info.h"
#include "nsig.h"
#include "number_set.h"
#include "delay.h"
#include "retval.h"
#include <limits.h>

#ifdef ENABLE_DATASERIES
# include <fcntl.h>
# include <sys/statfs.h>
# include <sys/stat.h>
# include <sys/time.h>
# include <sys/resource.h>
# include <sys/socket.h>
#endif /* ENABLE_DATASERIES */

/* for struct iovec */
#include <sys/uio.h>

/* for __X32_SYSCALL_BIT */
#include "scno.h"

#include "regs.h"

#if defined(SPARC64)
# undef PTRACE_GETREGS
# define PTRACE_GETREGS PTRACE_GETREGS64
# undef PTRACE_SETREGS
# define PTRACE_SETREGS PTRACE_SETREGS64
#endif

#include "syscall.h"
#include "xstring.h"
#include "syscallent_base_nr.h"

/* Define these shorthand notations to simplify the syscallent files. */
#include "sysent_shorthand_defs.h"

#define SEN(syscall_name) SEN_ ## syscall_name, SYS_FUNC_NAME(sys_ ## syscall_name)

const struct_sysent sysent0[] = {
#include "syscallent.h"
};

#if SUPPORTED_PERSONALITIES > 1
# include PERSONALITY1_INCLUDE_FUNCS
static const struct_sysent sysent1[] = {
# include "syscallent1.h"
};
#endif

#if SUPPORTED_PERSONALITIES > 2
# include PERSONALITY2_INCLUDE_FUNCS
static const struct_sysent sysent2[] = {
# include "syscallent2.h"
};
#endif

/* Now undef them since short defines cause wicked namespace pollution. */
#include "sysent_shorthand_undefs.h"

const char *const errnoent[] = {
#include "errnoent.h"
};
const char *const signalent[] = {
#include "signalent.h"

};
/*
 * `ioctlent[012].h' files are automatically generated by the auxiliary
 * program `ioctlsort', such that the list is sorted by the `code' field.
 * This has the side-effect of resolving the _IO.. macros into
 * plain integers, eliminating the need to include here everything
 * in "/usr/include".
 */

const struct_ioctlent ioctlent0[] = {
#include "ioctlent0.h"
};

#if SUPPORTED_PERSONALITIES > 1
static const struct_ioctlent ioctlent1[] = {
# include "ioctlent1.h"
};
# include PERSONALITY0_INCLUDE_PRINTERS_DECLS
static const struct_printers printers0 = {
# include PERSONALITY0_INCLUDE_PRINTERS_DEFS
};
# include PERSONALITY1_INCLUDE_PRINTERS_DECLS
static const struct_printers printers1 = {
# include PERSONALITY1_INCLUDE_PRINTERS_DEFS
};
#endif

#if SUPPORTED_PERSONALITIES > 2
static const struct_ioctlent ioctlent2[] = {
# include "ioctlent2.h"
};
# include PERSONALITY2_INCLUDE_PRINTERS_DECLS
static const struct_printers printers2 = {
# include PERSONALITY2_INCLUDE_PRINTERS_DEFS
};
#endif

enum {
	nsyscalls0 = ARRAY_SIZE(sysent0)
#if SUPPORTED_PERSONALITIES > 1
	, nsyscalls1 = ARRAY_SIZE(sysent1)
# if SUPPORTED_PERSONALITIES > 2
	, nsyscalls2 = ARRAY_SIZE(sysent2)
# endif
#endif
};

enum {
	nioctlents0 = ARRAY_SIZE(ioctlent0)
#if SUPPORTED_PERSONALITIES > 1
	, nioctlents1 = ARRAY_SIZE(ioctlent1)
# if SUPPORTED_PERSONALITIES > 2
	, nioctlents2 = ARRAY_SIZE(ioctlent2)
# endif
#endif
};

#if SUPPORTED_PERSONALITIES > 1
const struct_sysent *sysent = sysent0;
const struct_ioctlent *ioctlent = ioctlent0;
const struct_printers *printers = &printers0;
#endif

const unsigned int nerrnos = ARRAY_SIZE(errnoent);
const unsigned int nsignals = ARRAY_SIZE(signalent);
unsigned nsyscalls = nsyscalls0;
unsigned nioctlents = nioctlents0;

const unsigned int nsyscall_vec[SUPPORTED_PERSONALITIES] = {
	nsyscalls0,
#if SUPPORTED_PERSONALITIES > 1
	nsyscalls1,
#endif
#if SUPPORTED_PERSONALITIES > 2
	nsyscalls2,
#endif
};
const struct_sysent *const sysent_vec[SUPPORTED_PERSONALITIES] = {
	sysent0,
#if SUPPORTED_PERSONALITIES > 1
	sysent1,
#endif
#if SUPPORTED_PERSONALITIES > 2
	sysent2,
#endif
};

const char *const personality_names[] =
#if defined X86_64
	{"64 bit", "32 bit", "x32"}
#elif defined X32
	{"x32", "32 bit"}
#elif SUPPORTED_PERSONALITIES == 2
	{"64 bit", "32 bit"}
#else
	{STRINGIFY_VAL(__WORDSIZE) " bit"}
#endif
	;

const char *const personality_designators[] =
#if defined X86_64
	{ "64", "32", "x32" }
#elif defined X32
	{ "x32", "32" }
#elif SUPPORTED_PERSONALITIES == 2
	{ "64", "32" }
#else
	{ STRINGIFY_VAL(__WORDSIZE) }
#endif
	;

#if SUPPORTED_PERSONALITIES > 1

unsigned current_personality;

# ifndef current_wordsize
unsigned current_wordsize = PERSONALITY0_WORDSIZE;
static const int personality_wordsize[SUPPORTED_PERSONALITIES] = {
	PERSONALITY0_WORDSIZE,
	PERSONALITY1_WORDSIZE,
#  if SUPPORTED_PERSONALITIES > 2
	PERSONALITY2_WORDSIZE,
#  endif
};
# endif

# ifndef current_klongsize
unsigned current_klongsize = PERSONALITY0_KLONGSIZE;
static const int personality_klongsize[SUPPORTED_PERSONALITIES] = {
	PERSONALITY0_KLONGSIZE,
	PERSONALITY1_KLONGSIZE,
#  if SUPPORTED_PERSONALITIES > 2
	PERSONALITY2_KLONGSIZE,
#  endif
};
# endif

void
set_personality(unsigned int personality)
{
	if (personality == current_personality)
		return;

	if (personality >= SUPPORTED_PERSONALITIES)
		error_msg_and_die("Requested switch to unsupported personality "
				  "%u", personality);

	nsyscalls = nsyscall_vec[personality];
	sysent = sysent_vec[personality];

	switch (personality) {
	case 0:
		ioctlent = ioctlent0;
		nioctlents = nioctlents0;
		printers = &printers0;
		break;

	case 1:
		ioctlent = ioctlent1;
		nioctlents = nioctlents1;
		printers = &printers1;
		break;

# if SUPPORTED_PERSONALITIES > 2
	case 2:
		ioctlent = ioctlent2;
		nioctlents = nioctlents2;
		printers = &printers2;
		break;
# endif
	}

	current_personality = personality;
# ifndef current_wordsize
	current_wordsize = personality_wordsize[personality];
# endif
# ifndef current_klongsize
	current_klongsize = personality_klongsize[personality];
# endif
}

static void
update_personality(struct tcb *tcp, unsigned int personality)
{
	static bool need_mpers_warning[] =
		{ false, !HAVE_PERSONALITY_1_MPERS, !HAVE_PERSONALITY_2_MPERS };

	set_personality(personality);

	if (personality == tcp->currpers)
		return;
	tcp->currpers = personality;

	if (!qflag) {
		error_msg("[ Process PID=%d runs in %s mode. ]",
			  tcp->pid, personality_names[personality]);
	}

	if (need_mpers_warning[personality]) {
		error_msg("WARNING: Proper structure decoding for this "
			  "personality is not supported, please consider "
			  "building strace with mpers support enabled.");
		need_mpers_warning[personality] = false;
	}
}
#endif

#ifdef SYS_socket_subcall
static void
decode_socket_subcall(struct tcb *tcp)
{
	const int call = tcp->u_arg[0];

	if (call < 1 || call >= SYS_socket_nsubcalls)
		return;

	const kernel_ulong_t scno = SYS_socket_subcall + call;
	const unsigned int nargs = sysent[scno].nargs;
	uint64_t buf[nargs];

	if (umoven(tcp, tcp->u_arg[1], nargs * current_wordsize, buf) < 0)
		return;

	tcp->scno = scno;
	tcp->qual_flg = qual_flags(scno);
	tcp->s_ent = &sysent[scno];

	unsigned int i;
	for (i = 0; i < nargs; ++i)
		tcp->u_arg[i] = (sizeof(uint32_t) == current_wordsize)
				? ((uint32_t *) (void *) buf)[i] : buf[i];
}
#endif /* SYS_socket_subcall */

#ifdef SYS_ipc_subcall
static void
decode_ipc_subcall(struct tcb *tcp)
{
	unsigned int call = tcp->u_arg[0];
	const unsigned int version = call >> 16;

	if (version) {
# if defined S390 || defined S390X
		return;
# else
#  ifdef SPARC64
		if (current_wordsize == 8)
			return;
#  endif
		set_tcb_priv_ulong(tcp, version);
		call &= 0xffff;
# endif
	}

	switch (call) {
		case  1: case  2: case  3: case  4:
		case 11: case 12: case 13: case 14:
		case 21: case 22: case 23: case 24:
			break;
		default:
			return;
	}

	tcp->scno = SYS_ipc_subcall + call;
	tcp->qual_flg = qual_flags(tcp->scno);
	tcp->s_ent = &sysent[tcp->scno];

	const unsigned int n = n_args(tcp);
	unsigned int i;
	for (i = 0; i < n; i++)
		tcp->u_arg[i] = tcp->u_arg[i + 1];
}
#endif /* SYS_ipc_subcall */

#ifdef SYS_syscall_subcall
/* The implementation is architecture specific.  */
static void decode_syscall_subcall(struct tcb *);
#endif /* SYS_syscall_subcall */

static void
dumpio(struct tcb *tcp)
{
	int fd = tcp->u_arg[0];
	if (fd < 0)
		return;

	if (is_number_in_set(fd, write_set)) {
		switch (tcp_sysent(tcp)->sen) {
		case SEN_write:
		case SEN_pwrite:
		case SEN_send:
		case SEN_sendto:
		case SEN_mq_timedsend_time32:
		case SEN_mq_timedsend_time64:
			dumpstr(tcp, tcp->u_arg[1], tcp->u_arg[2]);
			break;
		case SEN_writev:
		case SEN_pwritev:
		case SEN_pwritev2:
		case SEN_vmsplice:
			dumpiov_upto(tcp, tcp->u_arg[2], tcp->u_arg[1], -1);
			break;
		case SEN_sendmsg:
			dumpiov_in_msghdr(tcp, tcp->u_arg[1], -1);
			break;
		case SEN_sendmmsg:
			dumpiov_in_mmsghdr(tcp, tcp->u_arg[1]);
			break;
		}
	}

	if (syserror(tcp))
		return;

	if (is_number_in_set(fd, read_set)) {
		switch (tcp_sysent(tcp)->sen) {
		case SEN_read:
		case SEN_pread:
		case SEN_recv:
		case SEN_recvfrom:
		case SEN_mq_timedreceive_time32:
		case SEN_mq_timedreceive_time64:
			dumpstr(tcp, tcp->u_arg[1], tcp->u_rval);
			return;
		case SEN_readv:
		case SEN_preadv:
		case SEN_preadv2:
			dumpiov_upto(tcp, tcp->u_arg[2], tcp->u_arg[1],
				     tcp->u_rval);
			return;
		case SEN_recvmsg:
			dumpiov_in_msghdr(tcp, tcp->u_arg[1], tcp->u_rval);
			return;
		case SEN_recvmmsg:
		case SEN_recvmmsg_time32:
		case SEN_recvmmsg_time64:
			dumpiov_in_mmsghdr(tcp, tcp->u_arg[1]);
			return;
		}
	}
}

static const char *
err_name(uint64_t err)
{
	return err < nerrnos ? errnoent[err] : NULL;
}

void
print_err(int64_t err, bool negated)
{
	const char *str = err_name(negated ? -err : err);

	if (!str || xlat_verbose(xlat_verbosity) != XLAT_STYLE_ABBREV)
		tprintf(negated ? "%" PRId64 : "%" PRIu64, err);
	if (!str || xlat_verbose(xlat_verbosity) == XLAT_STYLE_RAW)
		return;
	(xlat_verbose(xlat_verbosity) == XLAT_STYLE_ABBREV
		? tprintf : tprintf_comment)("%s%s",
					     negated ? "-" : "", str);
}

static void
print_err_ret(kernel_ulong_t ret, unsigned long u_error)
{
	const char *u_error_str = err_name(u_error);

	if (u_error_str)
		tprintf("= %" PRI_kld " %s (%s)",
			ret, u_error_str, strerror(u_error));
	else
		tprintf("= %" PRI_kld " (errno %lu)", ret, u_error);
}

static long get_regs(struct tcb *);
static int get_syscall_args(struct tcb *);
static int get_syscall_result(struct tcb *);
static void get_error(struct tcb *, bool);
static void set_error(struct tcb *, unsigned long);
static void set_success(struct tcb *, kernel_long_t);
static int arch_get_scno(struct tcb *);
static int arch_check_scno(struct tcb *);
static int arch_set_scno(struct tcb *, kernel_ulong_t);
static int arch_get_syscall_args(struct tcb *);
static void arch_get_error(struct tcb *, bool);
static int arch_set_error(struct tcb *);
static int arch_set_success(struct tcb *);
#if MAX_ARGS > 6
static void arch_get_syscall_args_extra(struct tcb *, unsigned int);
#endif

struct inject_opts *inject_vec[SUPPORTED_PERSONALITIES];

static struct inject_opts *
tcb_inject_opts(struct tcb *tcp)
{
	return (scno_in_range(tcp->scno) && tcp->inject_vec[current_personality])
	       ? &tcp->inject_vec[current_personality][tcp->scno] : NULL;
}


static long
tamper_with_syscall_entering(struct tcb *tcp, unsigned int *signo)
{
	if (!tcp->inject_vec[current_personality]) {
		tcp->inject_vec[current_personality] =
			xcalloc(nsyscalls, sizeof(**inject_vec));
		memcpy(tcp->inject_vec[current_personality],
		       inject_vec[current_personality],
		       nsyscalls * sizeof(**inject_vec));
	}

	struct inject_opts *opts = tcb_inject_opts(tcp);

	if (!opts || opts->first == 0)
		return 0;

	--opts->first;

	if (opts->first != 0)
		return 0;

	opts->first = opts->step;

	if (!recovering(tcp)) {
		if (opts->data.flags & INJECT_F_SIGNAL)
			*signo = opts->data.signo;
		if (opts->data.flags & (INJECT_F_ERROR | INJECT_F_RETVAL)) {
			kernel_long_t scno =
				(opts->data.flags & INJECT_F_SYSCALL)
				? (kernel_long_t) shuffle_scno(opts->data.scno)
				: -1;

			if (!arch_set_scno(tcp, scno)) {
				tcp->flags |= TCB_TAMPERED;
				if (scno != -1)
					tcp->flags |= TCB_TAMPERED_NO_FAIL;
#if ARCH_NEEDS_SET_ERROR_FOR_SCNO_TAMPERING
				/*
				 * So far it's just a workaround for hppa,
				 * but let's pretend it could be used elsewhere.
				 */
				else {
					kernel_long_t rval =
						(opts->data.flags & INJECT_F_RETVAL) ?
						ENOSYS : retval_get(opts->data.rval_idx);

					tcp->u_error = 0; /* force reset */
					set_error(tcp, rval);
				}
#endif
			}
		}
		if (opts->data.flags & INJECT_F_DELAY_ENTER)
			delay_tcb(tcp, opts->data.delay_idx, true);
		if (opts->data.flags & INJECT_F_DELAY_EXIT)
			tcp->flags |= TCB_INJECT_DELAY_EXIT;
	}

	return 0;
}

static long
tamper_with_syscall_exiting(struct tcb *tcp)
{
	struct inject_opts *opts = tcb_inject_opts(tcp);
	if (!opts)
		return 0;

	if (inject_delay_exit(tcp))
		delay_tcb(tcp, opts->data.delay_idx, false);

	if (!syscall_tampered(tcp))
		return 0;

	if (!syserror(tcp) ^ !!syscall_tampered_nofail(tcp)) {
		error_msg("Failed to tamper with process %d: unexpectedly got"
			  " %serror (return value %#" PRI_klx ", error %lu)",
			  tcp->pid, syscall_tampered_nofail(tcp) ? "" : "no ",
			  tcp->u_rval, tcp->u_error);

		return 1;
	}

	if (opts->data.flags & INJECT_F_RETVAL)
		set_success(tcp, retval_get(opts->data.rval_idx));
	else
		set_error(tcp, retval_get(opts->data.rval_idx));

	return 0;
}

/*
 * Returns:
 * 0: "ignore this ptrace stop", bail out silently.
 * 1: ok, decoded; call
 *    syscall_entering_finish(tcp, syscall_entering_trace(tcp, ...)).
 * other: error; call syscall_entering_finish(tcp, res), where res is the value
 *    returned.
 */
int
syscall_entering_decode(struct tcb *tcp)
{
	int res = get_scno(tcp);
	if (res == 0)
		return res;
	if (res != 1 || (res = get_syscall_args(tcp)) != 1) {
		printleader(tcp);
		tprintf("%s(", tcp_sysent(tcp)->sys_name);
		/*
		 * " <unavailable>" will be added later by the code which
		 * detects ptrace errors.
		 */
		return res;
	}

#ifdef SYS_syscall_subcall
	if (tcp_sysent(tcp)->sen == SEN_syscall)
		decode_syscall_subcall(tcp);
#endif
#if defined SYS_ipc_subcall	\
 || defined SYS_socket_subcall
	switch (tcp_sysent(tcp)->sen) {
# ifdef SYS_ipc_subcall
		case SEN_ipc:
			decode_ipc_subcall(tcp);
			break;
# endif
# ifdef SYS_socket_subcall
		case SEN_socketcall:
			decode_socket_subcall(tcp);
			break;
# endif
	}
#endif

	return 1;
}

int
syscall_entering_trace(struct tcb *tcp, unsigned int *sig)
{
	if (hide_log(tcp)) {
		/*
		 * Restrain from fault injection
		 * while the trace executes strace code.
		 */
		tcp->qual_flg &= ~QUAL_INJECT;

		switch (tcp_sysent(tcp)->sen) {
			case SEN_execve:
			case SEN_execveat:
			case SEN_execv:
				/*
				 * First exec* syscall makes the log visible.
				 */
				tcp->flags &= ~TCB_HIDE_LOG;
				/*
				 * Check whether this exec* syscall succeeds.
				 */
				tcp->flags |= TCB_CHECK_EXEC_SYSCALL;
				break;
		}
	}

	if (hide_log(tcp) || !traced(tcp) || (tracing_paths && !pathtrace_match(tcp))) {
		tcp->flags |= TCB_FILTERED;
		return 0;
	}

	tcp->flags &= ~TCB_FILTERED;

	if (inject(tcp))
		tamper_with_syscall_entering(tcp, sig);

	if (cflag == CFLAG_ONLY_STATS) {
		return 0;
	}

#ifdef ENABLE_STACKTRACE
	if (stack_trace_enabled) {
		if (tcp_sysent(tcp)->sys_flags & STACKTRACE_CAPTURE_ON_ENTER)
			unwind_tcb_capture(tcp);
	}
#endif

	if (!is_complete_set(status_set, NUMBER_OF_STATUSES))
		strace_open_memstream(tcp);

	printleader(tcp);
	tprintf("%s(", tcp_sysent(tcp)->sys_name);
	int res = raw(tcp) ? printargs(tcp) : tcp_sysent(tcp)->sys_func(tcp);
	fflush(tcp->outf);
	return res;
}

void
syscall_entering_finish(struct tcb *tcp, int res)
{
	tcp->flags |= TCB_INSYSCALL;
	tcp->sys_func_rval = res;

#ifdef ENABLE_DATASERIES
	/*
	 * Arguments such as pathname or read/write buffer passed to
	 * system calls cannot be referenced directly from tcp->u_args.
	 * These arguments are copied from the address space of actual
	 * process being traced and stored in an array of pointers
	 * named as v_args.
	 */
	void *v_args[DS_MAX_ARGS];
	void *common_fields[DS_NUM_COMMON_FIELDS];
	bool exit_generated = false;
	int continuation_number;
	/*
	 * Get a timestamp for time_called and store it as a timeval
	 * in tcp->etime.
	 */
	if (ds_module) {
		clock_gettime(CLOCK_MONOTONIC, &tcp->etime);
		/* initialize v_args and common_fields with NULL */
		memset(v_args, 0, sizeof(void *) * DS_MAX_ARGS);
		memset(common_fields, 0, sizeof(void *)
					 * DS_NUM_COMMON_FIELDS);

		/*
		 * Then, store the common field values.
		 * Since _exit(2) and execve system calls do not return,
		 * we are not setting time_returned, return value
		 * and error numbers in our replayer.  We are only
		 * setting time_called and executing pid fields.
		 */
		common_fields[DS_COMMON_FIELD_TIME_CALLED] =
						&tcp->etime;
		common_fields[DS_COMMON_FIELD_EXECUTING_PID] =
						&tcp->pid;
		common_fields[DS_COMMON_FIELD_SYSCALL_NUM] =
						&tcp->scno;

		/*
		 * Linux has a unique implementation of threads.  To the
		 * Linux kernel, there is no concept of a thread.  Linux
		 * implements all threads as standard processes.  Therefore,
		 * pid is same as tid.
		 */
		common_fields[DS_COMMON_FIELD_EXECUTING_TID] =
						&tcp->pid;

		switch (tcp->s_ent->sen) {
		case SEN_vfork:
		case SEN_clone:
		        tcp->clone_dsid = ds_get_next_id(ds_module);
			break;
		case SEN_exit: /* exit system call */
			/*
			 * For _exit(2) system call, trace_syscall_exiting()
			 * function is not called.  So, to capture traces for
			 * _exit(2) system call, we should do this in
			 * trace_syscall_entering() function.
			 */
			if (exiting(tcp))
				exit_generated = true;
			v_args[0] = &exit_generated;

			ds_write_record(ds_module, "exit", tcp->u_arg,
					common_fields, v_args);
			v_args[0] = NULL;
			common_fields[DS_COMMON_FIELD_TIME_RETURNED] = &tcp->etime;
			break;
		case SEN_execve: /* execve system call */
			/*
			 * execve(2) system call does not return on success
			 * and the memory segments of calling process is
			 * overwritten by that of program loaded.  So we should
			 * capture traces in trace_syscall_entering() function.
			 * The execve system call can accept arbitrary number
			 * of arguments.  Continuation numbers are used to
			 * record all the arguments.  First record has a
			 * zero continuation number.  Each subsequent records
			 * have an incrementing continuation number.
			 */
			continuation_number = 0;
			v_args[0] = &continuation_number;
			v_args[1] = ds_get_path(tcp, tcp->u_arg[0]);

			/* Add first record to the dataseries file. */
			ds_write_record(ds_module, "execve", tcp->u_arg,
					common_fields, v_args);
			v_args[0] = NULL;
			if (v_args[1]) {
				free(v_args[1]);
				v_args[1] = NULL;
			}

			/* Then, write records for each argument variable. */
			ds_write_execve_records(tcp, tcp->u_arg[1],
						"arg", &continuation_number,
						common_fields, v_args);

			/*
			 * Lastly, write records for each environment
			 * variable.
			 */
			ds_write_execve_records(tcp, tcp->u_arg[2],
						"env", &continuation_number,
						common_fields, v_args);
			break;
		}
	}
	else if ((Tflag || cflag) && !filtered(tcp))
		clock_gettime(CLOCK_MONOTONIC, &tcp->etime);
#else /* !ENABLE_DATASERIES */
	/* Measure the entrance time as late as possible to avoid errors. */
	if ((Tflag || cflag) && !filtered(tcp))
		clock_gettime(CLOCK_MONOTONIC, &tcp->etime);
#endif /* !ENABLE_DATASERIES */

	/* Start tracking system time */
	if (cflag) {
		if (debug_flag) {
			struct timespec dt;

			ts_sub(&dt, &tcp->stime, &tcp->ltime);

			if (ts_nz(&dt))
				debug_func_msg("pid %d: %.9f seconds of system "
					       "time spent since the last "
					       "syscall exit",
					       tcp->pid, ts_float(&dt));
		}

		tcp->ltime = tcp->stime;
	}
}

/* Returns:
 * 0: "bail out".
 * 1: ok.
 * -1: error in one of ptrace ops.
 *
 * If not 0, call syscall_exiting_trace(tcp, res), where res is the return
 *    value. Anyway, call syscall_exiting_finish(tcp) then.
 */
int
syscall_exiting_decode(struct tcb *tcp, struct timespec *pts)
{
#ifdef ENABLE_DATASERIES
	/* Get a time stamp for time_returned and store as in a timeval tv. */
	if (ds_module) {
		clock_gettime(CLOCK_MONOTONIC, pts);
	}
	else if ((Tflag || cflag) && !filtered(tcp))
		clock_gettime(CLOCK_MONOTONIC, pts);
#else /* !ENABLE_DATASERIES */
	/* Measure the exit time as early as possible to avoid errors. */
	if ((Tflag || cflag) && !filtered(tcp))
		clock_gettime(CLOCK_MONOTONIC, pts);
#endif /* !ENABLE_DATASERIES */

	if (tcp_sysent(tcp)->sys_flags & MEMORY_MAPPING_CHANGE)
		mmap_notify_report(tcp);

	if (filtered(tcp))
		return 0;

	if (check_exec_syscall(tcp)) {
		/* The check failed, hide the log.  */
		tcp->flags |= TCB_HIDE_LOG;
	}

#if SUPPORTED_PERSONALITIES > 1
	update_personality(tcp, tcp->currpers);
#endif

	return get_syscall_result(tcp);
}

void
print_syscall_resume(struct tcb *tcp)
{
	/* If not in -ff mode, and printing_tcp != tcp,
	 * then the log currently does not end with output
	 * of _our syscall entry_, but with something else.
	 * We need to say which syscall's return is this.
	 *
	 * Forced reprinting via TCB_REPRINT is used only by
	 * "strace -ff -oLOG test/threaded_execve" corner case.
	 * It's the only case when -ff mode needs reprinting.
	 */
	if ((followfork < 2 && printing_tcp != tcp && !tcp->staged_output_data)
	    || (tcp->flags & TCB_REPRINT)) {
		tcp->flags &= ~TCB_REPRINT;
		printleader(tcp);
		tprintf("<... %s resumed>", tcp_sysent(tcp)->sys_name);
	}
}

int
syscall_exiting_trace(struct tcb *tcp, struct timespec *ts, int res)
{
#ifdef ENABLE_DATASERIES
	/*
	 * Arguments such as pathname or read/write buffer passed to
	 * system calls cannot be referenced directly from tcp->u_args.
	 * These arguments are copied from the address space of actual
	 * process being traced and stored in an array of pointers
	 * named as v_args.
	 */
	void *v_args[DS_MAX_ARGS];
	void *common_fields[DS_NUM_COMMON_FIELDS];
	int iov_number, continuation_number;
	socklen_t ulen;
	struct msghdr *msg;
#endif /* ENABLE_DATASERIES */
	if (syscall_tampered(tcp) || inject_delay_exit(tcp))
		tamper_with_syscall_exiting(tcp);

	if (cflag) {
		count_syscall(tcp, ts);
		if (cflag == CFLAG_ONLY_STATS) {
			return 0;
		}
	}

	print_syscall_resume(tcp);
	printing_tcp = tcp;

	tcp->s_prev_ent = NULL;
	if (res != 1) {
		/* There was error in one of prior ptrace ops */
		tprints(") ");
		tabto();
		tprints("= ? <unavailable>\n");
		if (!is_complete_set(status_set, NUMBER_OF_STATUSES)) {
			bool publish = is_number_in_set(STATUS_UNAVAILABLE,
							status_set);
			strace_close_memstream(tcp, publish);
		}
		line_ended();
		return res;
	}
	tcp->s_prev_ent = tcp->s_ent;

	int sys_res = 0;
	if (raw(tcp)) {
		/* sys_res = printargs(tcp); - but it's nop on sysexit */
	} else {
		if (tcp->sys_func_rval & RVAL_DECODED)
			sys_res = tcp->sys_func_rval;
		else
			sys_res = tcp_sysent(tcp)->sys_func(tcp);
	}

	if (!is_complete_set(status_set, NUMBER_OF_STATUSES)) {
		bool publish = syserror(tcp)
			       && is_number_in_set(STATUS_FAILED, status_set);
		publish |= !syserror(tcp)
			   && is_number_in_set(STATUS_SUCCESSFUL, status_set);
		strace_close_memstream(tcp, publish);
		if (!publish) {
			line_ended();
			return 0;
		}
	}

	tprints(") ");
	tabto();

	if (raw(tcp)) {
		if (tcp->u_error)
			print_err_ret(tcp->u_rval, tcp->u_error);
		else
			tprintf("= %#" PRI_klx, tcp->u_rval);

		if (syscall_tampered(tcp))
			tprints(" (INJECTED)");
	} else if (!(sys_res & RVAL_NONE) && tcp->u_error) {
		switch (tcp->u_error) {
		/* Blocked signals do not interrupt any syscalls.
		 * In this case syscalls don't return ERESTARTfoo codes.
		 *
		 * Deadly signals set to SIG_DFL interrupt syscalls
		 * and kill the process regardless of which of the codes below
		 * is returned by the interrupted syscall.
		 * In some cases, kernel forces a kernel-generated deadly
		 * signal to be unblocked and set to SIG_DFL (and thus cause
		 * death) if it is blocked or SIG_IGNed: for example, SIGSEGV
		 * or SIGILL. (The alternative is to leave process spinning
		 * forever on the faulty instruction - not useful).
		 *
		 * SIG_IGNed signals and non-deadly signals set to SIG_DFL
		 * (for example, SIGCHLD, SIGWINCH) interrupt syscalls,
		 * but kernel will always restart them.
		 */
		case ERESTARTSYS:
			/* Most common type of signal-interrupted syscall exit code.
			 * The system call will be restarted with the same arguments
			 * if SA_RESTART is set; otherwise, it will fail with EINTR.
			 */
			tprints("= ? ERESTARTSYS (To be restarted if SA_RESTART is set)");
			break;
		case ERESTARTNOINTR:
			/* Rare. For example, fork() returns this if interrupted.
			 * SA_RESTART is ignored (assumed set): the restart is unconditional.
			 */
			tprints("= ? ERESTARTNOINTR (To be restarted)");
			break;
		case ERESTARTNOHAND:
			/* pause(), rt_sigsuspend() etc use this code.
			 * SA_RESTART is ignored (assumed not set):
			 * syscall won't restart (will return EINTR instead)
			 * even after signal with SA_RESTART set. However,
			 * after SIG_IGN or SIG_DFL signal it will restart
			 * (thus the name "restart only if has no handler").
			 */
			tprints("= ? ERESTARTNOHAND (To be restarted if no handler)");
			break;
		case ERESTART_RESTARTBLOCK:
			/* Syscalls like nanosleep(), poll() which can't be
			 * restarted with their original arguments use this
			 * code. Kernel will execute restart_syscall() instead,
			 * which changes arguments before restarting syscall.
			 * SA_RESTART is ignored (assumed not set) similarly
			 * to ERESTARTNOHAND. (Kernel can't honor SA_RESTART
			 * since restart data is saved in "restart block"
			 * in task struct, and if signal handler uses a syscall
			 * which in turn saves another such restart block,
			 * old data is lost and restart becomes impossible)
			 */
			tprints("= ? ERESTART_RESTARTBLOCK (Interrupted by signal)");
			break;
		default:
			print_err_ret(tcp->u_rval, tcp->u_error);
			break;
		}
		if (syscall_tampered(tcp))
			tprints(" (INJECTED)");
		if ((sys_res & RVAL_STR) && tcp->auxstr)
			tprintf(" (%s)", tcp->auxstr);
	} else {
		if (sys_res & RVAL_NONE)
			tprints("= ?");
		else {
			switch (sys_res & RVAL_MASK) {
			case RVAL_HEX:
#if ANY_WORDSIZE_LESS_THAN_KERNEL_LONG
				if (current_klongsize < sizeof(tcp->u_rval)) {
					tprintf("= %#x",
						(unsigned int) tcp->u_rval);
				} else
#endif
				{
					tprintf("= %#" PRI_klx, tcp->u_rval);
				}
				break;
			case RVAL_OCTAL:
				tprints("= ");
				print_numeric_long_umask(tcp->u_rval);
				break;
			case RVAL_UDECIMAL:
#if ANY_WORDSIZE_LESS_THAN_KERNEL_LONG
				if (current_klongsize < sizeof(tcp->u_rval)) {
					tprintf("= %u",
						(unsigned int) tcp->u_rval);
				} else
#endif
				{
					tprintf("= %" PRI_klu, tcp->u_rval);
				}
				break;
			case RVAL_FD:
				if (show_fd_path) {
					tprints("= ");
					printfd(tcp, tcp->u_rval);
				} else
					tprintf("= %" PRI_kld, tcp->u_rval);
				break;
			default:
				error_msg("invalid rval format");
				break;
			}
		}
		if ((sys_res & RVAL_STR) && tcp->auxstr)
			tprintf(" (%s)", tcp->auxstr);
		if (syscall_tampered(tcp))
			tprints(" (INJECTED)");
	}
	if (Tflag) {
		ts_sub(ts, ts, &tcp->etime);
		tprintf(" <%ld.%06ld>",
			(long) ts->tv_sec, (long) ts->tv_nsec / 1000);
	}
	tprints("\n");
	dumpio(tcp);
	line_ended();

#ifdef ENABLE_STACKTRACE
	if (stack_trace_enabled)
		unwind_tcb_print(tcp);
#endif
#ifdef ENABLE_DATASERIES
	if (ds_module) {
		/*
		 * Write record in dataseries file for the system call which
		 * is being traced.
		 */

		/*
		 * First, initialize v_args and common_fields with NULL
		 * arguments.
		 */
		memset(v_args, 0, sizeof(void *) * DS_MAX_ARGS);
		memset(common_fields, 0, sizeof(void *) * DS_NUM_COMMON_FIELDS);

		/* Then, store the common field values */
		common_fields[DS_COMMON_FIELD_TIME_CALLED] = &tcp->etime;
		common_fields[DS_COMMON_FIELD_TIME_RETURNED] = ts;
		common_fields[DS_COMMON_FIELD_RETURN_VALUE] = &tcp->u_rval;
		common_fields[DS_COMMON_FIELD_ERRNO_NUMBER] = &tcp->u_error;
		common_fields[DS_COMMON_FIELD_EXECUTING_PID] = &tcp->pid;
		common_fields[DS_COMMON_FIELD_SYSCALL_NUM] = &tcp->scno;
		common_fields[DS_COMMON_FIELD_BUFFER_NOT_CAPTURED] = (void *) false;
		/*
		 * Linux has a unique implementation of threads.  To the
		 * Linux kernel, there is no concept of a thread.  Linux
		 * implements all threads as standard processes.  Therefore,
		 * pid is same as tid.
		 */
		common_fields[DS_COMMON_FIELD_EXECUTING_TID] = &tcp->pid;
		switch (tcp->s_ent->sen) {
			case SEN_open: /* open system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "open", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_openat: /* openat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "openat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_close: /* close system call */
				ds_write_record(ds_module, "close", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_read: /* read system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_rval);
				ds_write_record(ds_module, "read", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_write: /* write system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				ds_write_record(ds_module, "write", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_chdir: /* chdir system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "chdir", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_chroot: /* chroot system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "chroot", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_mkdir: /* mkdir system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "mkdir", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_mkdirat: /* mkdirat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "mkdirat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_rmdir: /* rmdir system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "rmdir", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_link: /* link system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "link", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_linkat: /* linkat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				v_args[1] = ds_get_path(tcp, tcp->u_arg[3]);
				ds_write_record(ds_module, "linkat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_symlink: /* symlink system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "symlink", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_symlinkat: /* symlinkat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_path(tcp, tcp->u_arg[2]);
				ds_write_record(ds_module, "symlinkat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_unlink: /* unlink system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "unlink", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_unlinkat: /* unlinkat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "unlinkat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_truncate: /* truncate system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "truncate", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_ftruncate: /* ftruncate system call */
				ds_write_record(ds_module, "ftruncate", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_flock: /* flock system call */
				ds_write_record(ds_module, "flock", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_creat: /* creat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "creat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_access: /* access system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "access", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_faccessat: /* faccessat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "faccessat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_chmod: /* chmod system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "chmod", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_umask: /* umask system call */
				ds_write_record(ds_module, "umask", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fchmod: /* fchmod system call */
				ds_write_record(ds_module, "fchmod", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fchmodat: /* fchmodat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "fchmodat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fchdir: /* fchmod system call */
				ds_write_record(ds_module, "fchdir", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_lseek: /* lseek system call */
				ds_write_record(ds_module, "lseek", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_pread: /* pread system call */
				v_args[0] =  ds_get_buffer(tcp, tcp->u_arg[1],
							   tcp->u_rval);
				ds_write_record(ds_module, "pread", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_pwrite: /* pwrite system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				ds_write_record(ds_module, "pwrite", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_stat: /* stat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct stat));
				ds_write_record(ds_module, "stat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_statfs: /* statfs system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct statfs));
				ds_write_record(ds_module, "statfs", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fstatfs: /* fstatfs system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct statfs));
				ds_write_record(ds_module, "fstatfs", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_chown: /* chown system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "chown", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_readlink: /* readlink system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_rval);
				ds_write_record(ds_module, "readlink", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_readv: /* readv system call */
				/* iov_number equals to '-1' denotes first record. */
				iov_number = -1;
				v_args[0] = &iov_number;
				v_args[1] = &tcp->u_rval;
				/* First, write the first record. */
				ds_write_record(ds_module, "readv", tcp->u_arg,
						common_fields, v_args);
				/*
				 * Then, iteratively write the record for each
				 * buffer passed in struct iovec.
				 */
				ds_write_iov_records(tcp, tcp->u_arg[1], "readv",
						common_fields, v_args, tcp->u_arg[2]);
				break;
			case SEN_writev: /* writev system call */
				/* iov_number equals to '-1' denotes first record. */
				iov_number = -1;
				v_args[0] = &iov_number;
				v_args[1] = &tcp->u_rval;
				/* First, write the first record. */
				ds_write_record(ds_module, "writev", tcp->u_arg,
						common_fields, v_args);
				/*
				 * Then, iteratively write the record for each
				 * buffer passed in struct iovec.
				 */
				ds_write_iov_records(tcp, tcp->u_arg[1], "writev",
						common_fields, v_args, tcp->u_arg[2]);
				break;
			case SEN_utime: /* utime system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct utimbuf));
				ds_write_record(ds_module, "utime", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_lstat: /* lstat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct stat));
				ds_write_record(ds_module, "lstat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fstat: /* fstat system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct stat));
				ds_write_record(ds_module, "fstat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_newfstatat: /* fstatat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[2],
							  sizeof(struct stat));
				ds_write_record(ds_module, "fstatat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_utimes: /* utimes system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  2 * sizeof(struct timespec));
				ds_write_record(ds_module, "utimes", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_utimensat_time32:
			case SEN_utimensat_time64: /* utimensat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[2],
							2 * sizeof(struct timespec));
				ds_write_record(ds_module, "utimensat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_rename: /* rename system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "rename", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fsync: /* fsync system call */
				ds_write_record(ds_module, "fsync", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_fdatasync: /* fdatasync system call */
				ds_write_record(ds_module, "fdatasync", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_fallocate: /* fallocate system call */
				ds_write_record(ds_module, "fallocate", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_readahead: /* readahead system call */
				ds_write_record(ds_module, "readahead", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_mknod: /* mknod system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				ds_write_record(ds_module, "mknod", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_mknodat: /* mknodat system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "mknodat", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_pipe: /* pipe system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[0],
							  2 * sizeof(int));
				ds_write_record(ds_module, "pipe", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_dup: /* dup system call */
				ds_write_record(ds_module, "dup", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_dup2: /* dup2 system call */
				ds_write_record(ds_module, "dup2", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_dup3: /* dup3 system call */
				ds_write_record(ds_module, "dup3", tcp->u_arg,
						common_fields, NULL);
				break;
			case SEN_execve: /* execve system call */
				/*
				 * continuation number equal to '-1' denotes the
				 * extra record which stores the common fields of
				 * execve system call.
				 */
				continuation_number = -1;
				v_args[0] = &continuation_number;
				ds_write_record(ds_module, "execve", tcp->u_arg,
						common_fields, v_args);
				v_args[0] = NULL;
				break;
			case SEN_mmap: /* mmap system call */
				ds_write_record(ds_module, "mmap", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_munmap: /* munmap system call */
				ds_write_record(ds_module, "munmap", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fcntl: /* fcntl system call */
				if ((tcp->u_arg[1] == F_SETLK) ||
				    (tcp->u_arg[1] == F_SETLKW) ||
				    (tcp->u_arg[1] == F_GETLK)) {
					v_args[0] = ds_get_buffer(tcp, tcp->u_arg[2],
								 sizeof(struct flock));
				}
				ds_write_record(ds_module, "fcntl", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_getdents: /* getdents system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_rval);
				ds_write_record(ds_module, "getdents", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_ioctl: /* ioctl system call */ {
				u_int ioctl_size = ds_get_ioctl_size(ds_module);
				if (ioctl_size > 0) {
					v_args[0] = ds_get_buffer(tcp, tcp->u_arg[2],
								  ioctl_size);
				} else {
					v_args[0] = NULL;
				}
				ds_write_record(ds_module, "ioctl", tcp->u_arg,
						common_fields, v_args);
				ds_set_ioctl_size(ds_module, 0);
				break;
			}
			case SEN_clone: /* clone system call */ {
				int ctid_index = ds_get_clone_ctid_index(ds_module);
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[2],
							  sizeof(int));
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[ctid_index],
							  sizeof(int));
				common_fields[DS_COMMON_FIELD_UNIQUE_ID] = &tcp->clone_dsid;
				ds_write_into_same_record(ds_module, "clone", tcp->u_arg,
							  common_fields, v_args);
				break;
			}
			case SEN_vfork: /* vfork system call */
				common_fields[DS_COMMON_FIELD_UNIQUE_ID] = &tcp->clone_dsid;
				ds_write_into_same_record(ds_module, "vfork", tcp->u_arg,
							  common_fields, v_args);
				break;
			case SEN_setrlimit: /* setrlimit system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
					sizeof(struct rlimit));
				ds_write_record(ds_module, "setrlimit", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_getrlimit: /* getrlimit system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  sizeof(struct rlimit));
				ds_write_record(ds_module, "getrlimit", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_setpgid: /* setpgid system call */
				ds_write_record(ds_module, "setpgid", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_setsid: /* setsid system call */
				ds_write_record(ds_module, "setsid", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_setxattr: /* lsetxattr and setxattr system calls */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_name(tcp, tcp->u_arg[1]);
				v_args[2] = ds_get_buffer(tcp, tcp->u_arg[2],
							  tcp->u_arg[3]);
				if (tcp->s_ent->sys_name[0] == 'l')
					ds_write_record(ds_module, "lsetxattr", tcp->u_arg,
							common_fields, v_args);
				else
					ds_write_record(ds_module, "setxattr", tcp->u_arg,
							common_fields, v_args);
				break;
			case SEN_getxattr: /* lgetxattr and getxattr system calls */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_name(tcp, tcp->u_arg[1]);
				v_args[2] = ds_get_buffer(tcp, tcp->u_arg[2],
							  tcp->u_rval);
				if (tcp->s_ent->sys_name[0] == 'l')
					ds_write_record(ds_module, "lgetxattr", tcp->u_arg,
							common_fields, v_args);
				else
					ds_write_record(ds_module, "getxattr", tcp->u_arg,
							common_fields, v_args);
				break;
			case SEN_fsetxattr: /* fsetxattr system call */
				v_args[0] = ds_get_name(tcp, tcp->u_arg[1]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[2],
							  tcp->u_arg[3]);
				ds_write_record(ds_module, "fsetxattr", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_fgetxattr: /* fgetxattr system call */
				v_args[0] = ds_get_name(tcp, tcp->u_arg[1]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[2],
							  tcp->u_rval);
				ds_write_record(ds_module, "fgetxattr", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_listxattr: /* Listxattr and Llistxattr system call */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_rval);
				if (tcp->s_ent->sys_name[1] == 'l')
					ds_write_record(ds_module, "llistxattr",
							tcp->u_arg, common_fields, v_args);
				else
					ds_write_record(ds_module, "listxattr",
							tcp->u_arg, common_fields, v_args);
				break;
			case SEN_flistxattr: /* Flistxattr system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_rval);
				ds_write_record(ds_module, "flistxattr", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_removexattr: /* Removexattr & LRemovexattr system calls */
				v_args[0] = ds_get_path(tcp, tcp->u_arg[0]);
				v_args[1] = ds_get_name(tcp, tcp->u_arg[1]);
				if (tcp->s_ent->sys_name[0] == 'l')
					ds_write_record(ds_module, "lremovexattr",
							tcp->u_arg, common_fields, v_args);
				else
					ds_write_record(ds_module, "removexattr",
							tcp->u_arg, common_fields, v_args);
				break;
			case SEN_fremovexattr: /* FRemovexattr system call */
				v_args[0] = ds_get_name(tcp, tcp->u_arg[1]);
				ds_write_record(ds_module, "fremovexattr", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_socket: /* Socket system call */
				ds_write_record(ds_module, "socket", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_epoll_create: /* epoll_create system call */
				ds_write_record(ds_module, "epoll_create", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_epoll_create1: /* epoll_create1 system call */
				ds_write_record(ds_module, "epoll_create1", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_connect:  /* Connect system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				ds_write_record(ds_module, "connect", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_bind:  /* Bind system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				ds_write_record(ds_module, "bind", tcp->u_arg,
						common_fields, v_args);
				break;
				/*
				 * NOTE: support for tracing the accept(2),
				 * getsockname(2) and getpeername(2) system
				 * calls is incomplete.  We do not currently
				 * record the struct sockaddr buffer and it
				 * is set as NULL in ds_module for now.  Nor
				 * do we record the value of the buffer's
				 * original length on syscall entry.
				 */
			case SEN_accept:  /* Accept system call */
				if ((!tcp->u_arg[2]) ||
				    (umoven(tcp, tcp->u_arg[2], sizeof(socklen_t), &ulen) < 0)) {
				  ulen = 0;
				}
				v_args[0] = &ulen;
				ds_write_record(ds_module, "accept", tcp->u_arg,
						common_fields, v_args);
				v_args[0] = NULL;
				break;
			case SEN_accept4:  /* Accept system call */
				if ((!tcp->u_arg[2]) ||
				    (umoven(tcp, tcp->u_arg[2], sizeof(socklen_t), &ulen) < 0)) {
				  ulen = 0;
				}
				v_args[0] = &ulen;
				ds_write_record(ds_module, "accept4", tcp->u_arg,
						common_fields, v_args);
				v_args[0] = NULL;
				break;
			case SEN_getsockname: /* Getsockname system call */
				if ((!tcp->u_arg[2]) ||
				    (umoven(tcp, tcp->u_arg[2], sizeof(socklen_t), &ulen) < 0)) {
				  ulen = 0;
				}
				v_args[0] = &ulen;
				ds_write_record(ds_module, "getsockname", tcp->u_arg,
						common_fields, v_args);
				v_args[0] = NULL;
				break;
			case SEN_getpeername: /* Getpeername system call*/
				if ((!tcp->u_arg[2]) ||
				    (umoven(tcp, tcp->u_arg[2], sizeof(socklen_t), &ulen) < 0)) {
				  ulen = 0;
				}
				v_args[0] = &ulen;
				ds_write_record(ds_module, "getpeername", tcp->u_arg,
						common_fields, v_args);
				v_args[0] = NULL;
				break;
			case SEN_listen: /* listen system call */
				ds_write_record(ds_module, "listen", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_shutdown: /*shutdown system call */
				ds_write_record(ds_module, "shutdown", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_socketpair: /* socketpair system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[3],
							  2 * sizeof(int));
				ds_write_record(ds_module, "socketpair", tcp->u_arg,
						common_fields, v_args);
				break;
				/*
				 * NOTE: support for tracing the
				 * getsockopt(2) system call is incomplete.
				 * We do not currently record the optval
				 * buffer and it is set as NULL in ds_module
				 * for now.  Nor do we record the value of
				 * the buffer's original length on syscall
				 * entry.
				 */
			case SEN_getsockopt: /* getsockopt system call */
				if ((!tcp->u_arg[4]) ||
				    (umoven(tcp, tcp->u_arg[4], sizeof(socklen_t), &ulen) < 0)) {
				  ulen = 0;
				}
				v_args[0] = &ulen;
				ds_write_record(ds_module, "getsockopt", tcp->u_arg,
						common_fields, v_args);
				v_args[0] = NULL;
				break;
			case SEN_setsockopt: /* setsockopt system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[3],
							  tcp->u_arg[4]);
				ds_write_record(ds_module, "setsockopt", tcp->u_arg,
						common_fields, v_args);
				break;
				/*
				 * NOTE: support for replaying the recv(2)
				 * system call is incomplete.
				 */
			case SEN_recv: /* recv system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				ds_write_record(ds_module,"recv", tcp->u_arg,
						common_fields, v_args);
				break;
				/*
				 * NOTE: support for replaying the
				 * recvfrom(2) system call is incomplete.
				 */
			case SEN_recvfrom: /* recvfrom system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				if ((!tcp->u_arg[5]) ||
				    (umoven(tcp, tcp->u_arg[5], sizeof(socklen_t), &ulen) < 0)) {
				  ulen = 0;
				}
				v_args[1] = &ulen;
				ds_write_record(ds_module, "recvfrom", tcp->u_arg,
						common_fields, v_args);
				v_args[1] = NULL;
				break;
				/*
				 * NOTE: support for replaying the
				 * recvmsg(2) system call is incomplete.
				 */
			case SEN_recvmsg: /* recvmsg system call*/
				msg = ds_get_buffer(tcp, tcp->u_arg[1],
						    sizeof(struct msghdr));
				/* iov_number equals to '-1' denotes first record */
				iov_number = -1;
				if (!msg) {
				  v_args[0] = NULL;
				  v_args[1] = NULL;
				} else {
				  v_args[0] = &iov_number;
				  v_args[1] = &tcp->u_rval;
				}
				/* Write the first record */
				ds_write_record(ds_module, "recvmsg", tcp->u_arg,
						common_fields, v_args);
				/*
				 * Then, iteratively write the record for each
				 * buffer passed in struct iovec.
				 */
				if (msg) {
				  ds_write_iov_records(tcp, (long)msg->msg_iov,
						       "recvmsg", common_fields,
						       v_args, msg->msg_iovlen);
				  free(msg);
				}
				break;
			case SEN_send: /* send system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				ds_write_record(ds_module, "send", tcp->u_arg,
						common_fields, v_args);
				break;
			case SEN_sendto: /* sendto system call */
				v_args[0] = ds_get_buffer(tcp, tcp->u_arg[1],
							  tcp->u_arg[2]);
				v_args[1] = ds_get_buffer(tcp, tcp->u_arg[4],
							  tcp->u_arg[5]);
				ds_write_record(ds_module, "sendto", tcp->u_arg,
						common_fields, v_args);
				break;
				/*
				 * NOTE: support for tracing the sendmsg
				 * system call is incomplete.  Currently, we
				 * do not record all the fields in the
				 * struct msghdr.
				 */
			case SEN_sendmsg: /* sendmsg system call */
				msg = ds_get_buffer(tcp, tcp->u_arg[1],
						    sizeof(struct msghdr));
				/* iov_number equals to '-1' denotes first record. */
				iov_number = -1;
				if (!msg) {
					v_args[0] = NULL;
					v_args[1] = NULL;
				} else {
					v_args[0] = &iov_number;
					v_args[1] = &tcp->u_rval;
				}
				/* Write the first record. */
				ds_write_record(ds_module, "sendmsg", tcp->u_arg,
						common_fields, v_args);
				/*
				 * Then, iteratively write the record for each
				 * buffer passed in struct iovec.
				 */
				if (msg) {
					ds_write_iov_records(tcp, (long)msg->msg_iov,
							     "sendmsg", common_fields,
							     v_args, msg->msg_iovlen);
					free(msg);
				}
				break;
			/*
			 * These system calls are chosen not be traced by
			 * fsl-strace.
			 */
			case SEN_brk:
			case SEN_mprotect:
			case SEN_arch_prctl:
			case SEN_rt_sigaction:
			case SEN_getpid:
			case SEN_wait4:
			case SEN_getrusage:
			case SEN_getcwd:
			case SEN_rt_sigprocmask:
			case SEN_mremap:
			case SEN_madvise:
			case SEN_rt_sigreturn:
			case SEN_sigreturn:
			case SEN_rt_sigsuspend:
			case SEN_getuid:
			case SEN_getgid:
			case SEN_geteuid:
			case SEN_getegid:
			case SEN_uname:
			case SEN_getppid:
			case SEN_getpgrp:
			case SEN_nanosleep_time32:
			case SEN_nanosleep_time64:
			case SEN_set_tid_address:
			case SEN_set_robust_list:
			case SEN_futex_time32:
			case SEN_futex_time64:
			case SEN_getgroups:
			case SEN_fadvise64:
			case SEN_sched_getaffinity:
			case SEN_sigaltstack:
			case SEN_poll_time32:
			case SEN_poll_time64:
			case SEN_select:
				ds_add_to_untraced_set(ds_module,
						       tcp->s_ent->sys_name,
						       tcp->scno);
				break;
			default:
				ds_print_warning(ds_module,
						 tcp->s_ent->sys_name,
						 tcp->scno);
		}
		/* Free memory allocated to v_args. */
		for (i = 0; i < DS_MAX_ARGS; i++) {
			if (v_args[i])
				free(v_args[i]);
		}
	}
#endif /* ENABLE_DATASERIES */
	return 0;
}

void
syscall_exiting_finish(struct tcb *tcp)
{
	tcp->flags &= ~(TCB_INSYSCALL | TCB_TAMPERED | TCB_INJECT_DELAY_EXIT);
	tcp->sys_func_rval = 0;
	free_tcb_priv_data(tcp);

	if (cflag)
		tcp->ltime = tcp->stime;
}

bool
is_erestart(struct tcb *tcp)
{
	switch (tcp->u_error) {
		case ERESTARTSYS:
		case ERESTARTNOINTR:
		case ERESTARTNOHAND:
		case ERESTART_RESTARTBLOCK:
			return true;
		default:
			return false;
	}
}

static unsigned long saved_u_error;

void
temporarily_clear_syserror(struct tcb *tcp)
{
	saved_u_error = tcp->u_error;
	tcp->u_error = 0;
}

void
restore_cleared_syserror(struct tcb *tcp)
{
	tcp->u_error = saved_u_error;
}

static struct ptrace_syscall_info ptrace_sci;

static bool
ptrace_syscall_info_is_valid(void)
{
	return ptrace_get_syscall_info_supported &&
	       ptrace_sci.op <= PTRACE_SYSCALL_INFO_SECCOMP;
}

#define XLAT_MACROS_ONLY
#include "xlat/nt_descriptor_types.h"
#undef XLAT_MACROS_ONLY

#define ARCH_MIGHT_USE_SET_REGS 1

#include "arch_regs.c"

#if HAVE_ARCH_GETRVAL2
# include "arch_getrval2.c"
#endif

#include "getregs_old.h"
#ifdef HAVE_GETREGS_OLD
/* Either getregs_old() or set_regs() */
# undef ARCH_MIGHT_USE_SET_REGS
# define ARCH_MIGHT_USE_SET_REGS 0
#endif

#undef ptrace_getregset_or_getregs
#undef ptrace_setregset_or_setregs
#ifdef ARCH_REGS_FOR_GETREGSET

# define ptrace_getregset_or_getregs ptrace_getregset
static long
ptrace_getregset(pid_t pid)
{
# ifdef ARCH_IOVEC_FOR_GETREGSET
	/* variable iovec */
	ARCH_IOVEC_FOR_GETREGSET.iov_len = sizeof(ARCH_REGS_FOR_GETREGSET);
	return ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS,
		      &ARCH_IOVEC_FOR_GETREGSET);
# else
	/* constant iovec */
	static struct iovec io = {
		.iov_base = &ARCH_REGS_FOR_GETREGSET,
		.iov_len = sizeof(ARCH_REGS_FOR_GETREGSET)
	};
	return ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &io);

# endif
}

# if ARCH_MIGHT_USE_SET_REGS
#  define ptrace_setregset_or_setregs ptrace_setregset
static int
ptrace_setregset(pid_t pid)
{
#  ifdef ARCH_IOVEC_FOR_GETREGSET
	/* variable iovec */
	return ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS,
		      &ARCH_IOVEC_FOR_GETREGSET);
#  else
	/* constant iovec */
	static struct iovec io = {
		.iov_base = &ARCH_REGS_FOR_GETREGSET,
		.iov_len = sizeof(ARCH_REGS_FOR_GETREGSET)
	};
	return ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &io);
#  endif
}
# endif /* ARCH_MIGHT_USE_SET_REGS */

#elif defined ARCH_REGS_FOR_GETREGS

# define ptrace_getregset_or_getregs ptrace_getregs
static long
ptrace_getregs(pid_t pid)
{
# if defined SPARC || defined SPARC64
	/* SPARC systems have the meaning of data and addr reversed */
	return ptrace(PTRACE_GETREGS, pid, (void *) &ARCH_REGS_FOR_GETREGS, 0);
# else
	return ptrace(PTRACE_GETREGS, pid, NULL, &ARCH_REGS_FOR_GETREGS);
# endif
}

# if ARCH_MIGHT_USE_SET_REGS
#  define ptrace_setregset_or_setregs ptrace_setregs
static int
ptrace_setregs(pid_t pid)
{
#  if defined SPARC || defined SPARC64
	/* SPARC systems have the meaning of data and addr reversed */
	return ptrace(PTRACE_SETREGS, pid, (void *) &ARCH_REGS_FOR_GETREGS, 0);
#  else
	return ptrace(PTRACE_SETREGS, pid, NULL, &ARCH_REGS_FOR_GETREGS);
#  endif
}
# endif /* ARCH_MIGHT_USE_SET_REGS */

#endif /* ARCH_REGS_FOR_GETREGSET || ARCH_REGS_FOR_GETREGS */

static long get_regs_error = -1;

void
clear_regs(struct tcb *tcp)
{
	ptrace_sci.op = 0xff;
	get_regs_error = -1;
}

static long
get_regs(struct tcb *const tcp)
{
#ifdef ptrace_getregset_or_getregs

	if (get_regs_error != -1)
		return get_regs_error;

# ifdef HAVE_GETREGS_OLD
	/*
	 * Try PTRACE_GETREGSET/PTRACE_GETREGS first,
	 * fallback to getregs_old.
	 */
	static int use_getregs_old;
	if (use_getregs_old < 0) {
		return get_regs_error = ptrace_getregset_or_getregs(tcp->pid);
	} else if (use_getregs_old == 0) {
		get_regs_error = ptrace_getregset_or_getregs(tcp->pid);
		if (get_regs_error >= 0) {
			use_getregs_old = -1;
			return get_regs_error;
		}
		if (errno == EPERM || errno == ESRCH)
			return get_regs_error;
		use_getregs_old = 1;
	}
	return get_regs_error = getregs_old(tcp);
# else /* !HAVE_GETREGS_OLD */
	/* Assume that PTRACE_GETREGSET/PTRACE_GETREGS works. */
	get_regs_error = ptrace_getregset_or_getregs(tcp->pid);

#  if defined ARCH_PERSONALITY_0_IOV_SIZE
	if (get_regs_error)
		return get_regs_error;

	switch (ARCH_IOVEC_FOR_GETREGSET.iov_len) {
	case ARCH_PERSONALITY_0_IOV_SIZE:
		update_personality(tcp, 0);
		break;
	case ARCH_PERSONALITY_1_IOV_SIZE:
		update_personality(tcp, 1);
		break;
	default: {
		static bool printed = false;

		if (!printed) {
			error_msg("Unsupported regset size returned by "
				  "PTRACE_GETREGSET: %zu",
				  ARCH_IOVEC_FOR_GETREGSET.iov_len);

			printed = true;
		}

		update_personality(tcp, 0);
	}
	}
#  endif /* ARCH_PERSONALITY_0_IOV_SIZE */

	return get_regs_error;

# endif /* !HAVE_GETREGS_OLD */

#else /* !ptrace_getregset_or_getregs */

# warning get_regs is not implemented for this architecture yet
	return 0;

#endif /* !ptrace_getregset_or_getregs */
}

#ifdef ptrace_setregset_or_setregs
static int
set_regs(pid_t pid)
{
	return ptrace_setregset_or_setregs(pid);
}
#endif /* ptrace_setregset_or_setregs */

struct sysent_buf {
	struct tcb *tcp;
	struct_sysent ent;
	char buf[sizeof("syscall_0x") + sizeof(kernel_ulong_t) * 2];
};

static void
free_sysent_buf(void *ptr)
{
	struct sysent_buf *s = ptr;
	s->tcp->s_prev_ent = s->tcp->s_ent = NULL;
	free(ptr);
}

static bool
strace_get_syscall_info(struct tcb *tcp)
{
	/*
	 * ptrace_get_syscall_info_supported should have been checked
	 * by the caller.
	 */
	if (ptrace_sci.op == 0xff) {
		const size_t size = sizeof(ptrace_sci);
		if (ptrace(PTRACE_GET_SYSCALL_INFO, tcp->pid,
			   (void *) size, &ptrace_sci) < 0) {
			get_regs_error = -2;
			return false;
		}
#if SUPPORTED_PERSONALITIES > 1
		int newpers = get_personality_from_syscall_info(&ptrace_sci);
		if (newpers >= 0)
			update_personality(tcp, newpers);
#endif
	}

	if (entering(tcp)) {
		if (ptrace_sci.op == PTRACE_SYSCALL_INFO_EXIT) {
			error_msg("pid %d: entering"
				  ", ptrace_syscall_info.op == %u",
				  tcp->pid, ptrace_sci.op);
			/* TODO: handle this.  */
		}
	} else {
		if (ptrace_sci.op == PTRACE_SYSCALL_INFO_ENTRY) {
			error_msg("pid %d: exiting"
				  ", ptrace_syscall_info.op == %u",
				  tcp->pid, ptrace_sci.op);
			/* TODO: handle this.  */
		}
	}

	return true;
}

bool
get_instruction_pointer(struct tcb *tcp, kernel_ulong_t *ip)
{
	if (get_regs_error < -1)
		return false;

	if (ptrace_get_syscall_info_supported) {
		if (!strace_get_syscall_info(tcp))
			return false;
		*ip = (kernel_ulong_t) ptrace_sci.instruction_pointer;
		return true;
	}

#if defined ARCH_PC_REG
	if (get_regs(tcp) < 0)
		return false;
	*ip = (kernel_ulong_t) ARCH_PC_REG;
	return true;
#elif defined ARCH_PC_PEEK_ADDR
	if (upeek(tcp, ARCH_PC_PEEK_ADDR, ip) < 0)
		return false;
	return true;
#else
# error Neither ARCH_PC_REG nor ARCH_PC_PEEK_ADDR is defined
#endif
}

bool
get_stack_pointer(struct tcb *tcp, kernel_ulong_t *sp)
{
	if (get_regs_error < -1)
		return false;

	if (ptrace_get_syscall_info_supported) {
		if (!strace_get_syscall_info(tcp))
			return false;
		*sp = (kernel_ulong_t) ptrace_sci.stack_pointer;
		return true;
	}

#if defined ARCH_SP_REG
	if (get_regs(tcp) < 0)
		return false;
	*sp = (kernel_ulong_t) ARCH_SP_REG;
	return true;
#elif defined ARCH_SP_PEEK_ADDR
	if (upeek(tcp, ARCH_SP_PEEK_ADDR, sp) < 0)
		return false;
	return true;
#else
	return false;
#endif
}

static int
get_syscall_regs(struct tcb *tcp)
{
	if (get_regs_error != -1)
		return get_regs_error;

	if (ptrace_get_syscall_info_supported)
		return strace_get_syscall_info(tcp) ? 0 : get_regs_error;

	return get_regs(tcp);
}

const struct_sysent stub_sysent = {
	.nargs = MAX_ARGS,
	.sys_flags = MEMORY_MAPPING_CHANGE,
	.sen = SEN_printargs,
	.sys_func = printargs,
	.sys_name = "????",
};

/*
 * Returns:
 * 0: "ignore this ptrace stop", syscall_entering_decode() should return a "bail
 *    out silently" code.
 * 1: ok, continue in syscall_entering_decode().
 * other: error, syscall_entering_decode() should print error indicator
 *    ("????" etc) and return an appropriate code.
 */
int
get_scno(struct tcb *tcp)
{
	tcp->scno = -1;
	tcp->s_ent = NULL;
	tcp->qual_flg = QUAL_RAW | DEFAULT_QUAL_FLAGS;

	if (get_syscall_regs(tcp) < 0)
		return -1;

	if (ptrace_syscall_info_is_valid()) {
		/*
		 * So far it's just a workaround for x32,
		 * but let's pretend it could be used elsewhere.
		 */
		int rc = arch_check_scno(tcp);
		if (rc != 1)
			return rc;
		tcp->scno = ptrace_sci.entry.nr;
	} else {
		int rc = arch_get_scno(tcp);
		if (rc != 1)
			return rc;
	}

	tcp->scno = shuffle_scno(tcp->scno);

	if (scno_is_valid(tcp->scno)) {
		tcp->s_ent = &sysent[tcp->scno];
		tcp->qual_flg = qual_flags(tcp->scno);
	} else {
		struct sysent_buf *s = xzalloc(sizeof(*s));

		s->tcp = tcp;
		s->ent = stub_sysent;
		s->ent.sys_name = s->buf;
		xsprintf(s->buf, "syscall_%#" PRI_klx, shuffle_scno(tcp->scno));

		tcp->s_ent = &s->ent;

		set_tcb_priv_data(tcp, s, free_sysent_buf);

		debug_msg("pid %d invalid syscall %#" PRI_klx,
			  tcp->pid, shuffle_scno(tcp->scno));
	}

	/*
	 * We refrain from argument decoding during recovering
	 * as tracee memory mappings has changed and the registers
	 * are very likely pointing to garbage already.
	 */
	if (recovering(tcp))
		tcp->qual_flg |= QUAL_RAW;

	return 1;
}

static int
get_syscall_args(struct tcb *tcp)
{
	if (ptrace_syscall_info_is_valid()) {
		const unsigned int n =
			MIN(ARRAY_SIZE(tcp->u_arg),
			    ARRAY_SIZE(ptrace_sci.entry.args));
		for (unsigned int i = 0; i < n; ++i)
			tcp->u_arg[i] = ptrace_sci.entry.args[i];
#if SUPPORTED_PERSONALITIES > 1
		if (tcp_sysent(tcp)->sys_flags & COMPAT_SYSCALL_TYPES) {
			for (unsigned int i = 0; i < n; ++i)
				tcp->u_arg[i] = (uint32_t) tcp->u_arg[i];
		}
#endif
		/*
		 * So far it's just a workaround for mips o32,
		 * but let's pretend it could be used elsewhere.
		 */
#if MAX_ARGS > 6
		arch_get_syscall_args_extra(tcp, n);
#endif
		return 1;
	}
	return arch_get_syscall_args(tcp);
}

#ifdef ENABLE_DATASERIES
/*
 * Returns:
 * 1: ok, update tcp
 * other: error, could not read stat file for the pid
 *
 * Reads /proc/<PID>/stat using pid from struct tcb.
 * On success, it parses the data read, and update struct tcb with
 * sid, pgid, ppid, euid of the process.
 * The structure of information in /proc/<PID>/stat has been defined
 * in struct procinfo - defs.h
 */
int
get_proc_info(struct tcb *tcp)
{
	int fd;
	char *stat_file_path = NULL, *stat_str = NULL, *s;
	int ret = 1;
	struct stat st;

	stat_file_path = xmalloc(PATH_MAX + 1);
	/*
	 * Note: On failure xmalloc will aborts the trace process
	 * with an error message to stderr
	 */

	sprintf(stat_file_path, "/proc/%d/stat", tcp->pid);

	ret = access(stat_file_path, R_OK);
	if (ret == -1)
		goto out_free;

	fd = open(stat_file_path, O_RDONLY);
	if (fd < 0) {
		ret = -1;
		goto out_free;
	}

	stat_str = xmalloc(PROC_MAX + 1);

	ret = read(fd, stat_str, PROC_MAX);
	if (ret < 0)
		goto out_fd;
	stat_str[PROC_MAX] = 0;

	/*
	 * /proc/<PID>/stat has the following format:
	 * `pid (process_name) state ppid ...'
	 * we can skip pointer to `state' by finding the last location of `)'
	 */
	s = strrchr(stat_str, ')') + 2;

	/* Skips process state. Reads parent pid, group id, session id */
	sscanf(s, "%*c %d %d %d", &tcp->ppid, &tcp->pgid, &tcp->sid);

	ret = stat(stat_file_path, &st);
	if (ret != -1)
		tcp->euid = st.st_uid;
	else
		tcp->euid = -1;

out_fd:
	close(fd);

out_free:
	if (stat_str) {
		free(stat_str);
		stat_str = NULL;
	}

	if (stat_file_path) {
		free(stat_file_path);
		stat_file_path = NULL;
	}

	return ret;
}
#endif /* ENABLE_DATASERIES */

#ifdef ptrace_getregset_or_getregs
# define get_syscall_result_regs get_syscall_regs
#else
static int get_syscall_result_regs(struct tcb *);
#endif

/* Returns:
 * 1: ok, continue in syscall_exiting_trace().
 * -1: error, syscall_exiting_trace() should print error indicator
 *    ("????" etc) and bail out.
 */
static int
get_syscall_result(struct tcb *tcp)
{
	if (get_syscall_result_regs(tcp) < 0)
		return -1;
	get_error(tcp,
		  (!(tcp_sysent(tcp)->sys_flags & SYSCALL_NEVER_FAILS)
			|| syscall_tampered(tcp))
                  && !syscall_tampered_nofail(tcp));

	return 1;
}

static void
get_error(struct tcb *tcp, const bool check_errno)
{
	if (ptrace_syscall_info_is_valid()) {
		if (ptrace_sci.exit.is_error) {
			tcp->u_rval = -1;
			tcp->u_error = -ptrace_sci.exit.rval;
		} else {
			tcp->u_error = 0;
			tcp->u_rval = ptrace_sci.exit.rval;
		}
	} else {
		tcp->u_error = 0;
		arch_get_error(tcp, check_errno);
	}
}

static void
set_error(struct tcb *tcp, unsigned long new_error)
{
	const unsigned long old_error = tcp->u_error;

	if (new_error == old_error || new_error > MAX_ERRNO_VALUE)
		return;

#ifdef ptrace_setregset_or_setregs
	/* if we are going to invoke set_regs, call get_regs first */
	if (get_regs(tcp) < 0)
		return;
#endif

	tcp->u_error = new_error;
	if (arch_set_error(tcp)) {
		tcp->u_error = old_error;
		/* arch_set_error does not update u_rval */
	} else {
		if (ptrace_syscall_info_is_valid())
			tcp->u_rval = -1;
		else
			get_error(tcp, !(tcp_sysent(tcp)->sys_flags &
					 SYSCALL_NEVER_FAILS));
	}
}

static void
set_success(struct tcb *tcp, kernel_long_t new_rval)
{
	const kernel_long_t old_rval = tcp->u_rval;

#ifdef ptrace_setregset_or_setregs
	/* if we are going to invoke set_regs, call get_regs first */
	if (get_regs(tcp) < 0)
		return;
#endif

	tcp->u_rval = new_rval;
	if (arch_set_success(tcp)) {
		tcp->u_rval = old_rval;
		/* arch_set_success does not update u_error */
	} else {
		if (ptrace_syscall_info_is_valid())
			tcp->u_error = 0;
		else
			get_error(tcp, !(tcp_sysent(tcp)->sys_flags &
					 SYSCALL_NEVER_FAILS));
	}
}

#include "get_scno.c"
#include "check_scno.c"
#include "set_scno.c"
#include "get_syscall_args.c"
#ifndef ptrace_getregset_or_getregs
# include "get_syscall_result.c"
#endif
#include "get_error.c"
#include "set_error.c"
#ifdef HAVE_GETREGS_OLD
# include "getregs_old.c"
#endif
#include "shuffle_scno.c"

const char *
syscall_name(kernel_ulong_t scno)
{
	return scno_is_valid(scno) ? sysent[scno].sys_name : NULL;
}
